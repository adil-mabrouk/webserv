
HTTP/1.0 201 Created

HTTP/1.0 201 Created

HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 403 Forbidden
Content-Length: 2256

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>403 – Forbidden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">403</div>
    <div class="error-title">Forbidden</div>
    <p class="error-message">
        The request failure is tied to application logic
   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 403 Forbidden
Content-Length: 2256

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>403 – Forbidden</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">403</div>
    <div class="error-title">Forbidden</div>
    <p class="error-message">
        The request failure is tied to application logic
   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 201 Created

HTTP/1.0 201 Created

HTTP/1.0 201 Created

HTTP/1.0 201 Created

HTTP/1.1 404 Not Found
Server: webserv
Date: Sat, 3 Jan 2026 16:56:54 GMT
Content-Type: text/html
Content-Length: 140

<html>
<head><title>404 Not Found</title></head>
<body>
<center><h1>404 Not Found</h1></center>
<hr><center>Webserv</center>
</body>
</html>HTTP/1.1 404 Not Found
Server: webserv
Date: Sat, 3 Jan 2026 16:56:54 GMT
Content-Type: text/html
Content-Length: 140

<html>
<head><title>404 Not Found</title></head>
<body>
<center><h1>404 Not Found</h1></center>
<hr><center>Webserv</center>
</body>
</html>HTTP/1.1 404 Not Found
Server: webserv
Date: Sat, 3 Jan 2026 16:57:08 GMT
Content-Type: text/html
Content-Length: 140

<html>
<head><title>404 Not Found</title></head>
<body>
<center><h1>404 Not Found</h1></center>
<hr><center>Webserv</center>
</body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:24 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:24 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:24 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:25 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:25 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:25 GMT
Content-Type: text/html
Content-Length: 341

<html>
<head><title>Indexof /home/amabrouk/amabrouk/Response/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/Response/</h1><hr><pre><a href="../">../</a>
<a href="logic.txt">logic.txt</a>
<a href="Response.cpp">Response.cpp</a>
<a href="Response.hpp">Response.hpp</a>
<a href="Response.o">Response.o</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:26 GMT
Content-Type: text/plain
Content-Length: 2049
Last-Modified: Sat, 3 Jan 2026 14:08:14 GMT

#ifndef RESPONSE_HPP
#define RESPONSE_HPP

#include "../Request/Request.hpp"
#include "../Configuration/config.hpp"
#include <sys/stat.h>
#include <sys/socket.h>
#include <unistd.h>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <utility>
#include <ctime>
#include <sstream>
#include <fcntl.h>
#include <cerrno>
#include <dirent.h>

using std::string;
using std::find;
using std::cout;
using std::vector;
using std::map;
using std::make_pair;
using std::pair;
using std::time;
using std::time_t;
using std::ostringstream;

class	Request;

// 204 status code for post?
class	Response
{
private:
	LocationConfig					location_config;

	Request							request;
	int								status_code;
	string							reason_phrase;
	vector< pair<string, string> >	headers;
	string							body;
public:
	Response();
	Response(const Request&, const LocationConfig&);
	Response(const LocationConfig&);

	string	fillDate(time_t);
	static string	fillContentType(string, int);
	string	fillLastModified(string);
	void	fillFileBody(int);
	void	fillDirBody(string, DIR*);

	void	statusCode301(const string&);
	void	statusCode302(const string&);
	void	statusCode400();
	void	statusCode401();
	void	statusCode403();
	void	statusCode404();
	void	statusCode500();
	void	statusCode501();

	void	GETDir(string);
	void	GETFile(string, int, struct stat*);
	void	GETResource();
	void	DELETEResource();

	const string							getResponse() const;
	int										getStatusCode() const;
	const string							getReasonPhrase() const;
	const vector< pair<string, string> >	getHeaders() const;
	const string							getBody() const;
};

#endif

//
//<html>
//<head><title>Index of /</title></head>
//<body>
//<h1>Index of /</h1><hr><pre><a href="../">../</a>
//<a href="dir1/">dir1/</a>                                              24-Nov-2025 14:04                   -
//<a href="index.nginx-debian.html">index.nginx-debian.html</a>                            24-Nov-2025 13:57                 612
//</pre><hr></body>
//</html>
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 16:57:46 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.0 404 Not Found
Content-Length: 6894

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>404 – Not Found</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    :root {
      --nord0: #2E3440;
      --nord1: #3B4252;
      --nord4: #D8DEE9;
      --nord6: #ECEFF4;
      --nord8: #88C0D0;
      --nord11: #BF616A;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      min-height: 100vh;
      background: var(--nord0);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--nord6);
      padding: 2rem;
    }

    .error-card {
      background: var(--nord1);
      width: min(720px, 100%);
      padding: clamp(2.5rem, 5vw, 4rem);
      border-radius: 16px;
      text-align: center;
      box-shadow: 0 30px 60px rgba(0, 0, 0, 0.45);
    }

    .error-code {
      font-size: clamp(5rem, 18vw, 8rem);
      font-weight: 800;
      color: var(--nord11);
      line-height: 1;
      margin-bottom: 1rem;
    }

    .error-title {
      font-size: clamp(1.8rem, 4vw, 2.4rem);
      margin-bottom: 1.2rem;
    }

    .error-message {
      font-size: clamp(1.05rem, 2.5vw, 1.25rem);
      color: var(--nord4);
      line-height: 1.7;
      margin-bottom: 2.5rem;
      max-width: 42ch;
      margin-left: auto;
      margin-right: auto;
    }

    .btn {
      font-size: clamp(0.95rem, 2.5vw, 1.05rem);
      padding: 0.8rem 1.6rem;
      border-radius: 10px;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .btn-primary {
      background: var(--nord8);
      color: var(--nord0);
      font-weight: 600;
    }

    .btn-primary:hover {
      opacity: 0.85;
    }

    .btn-secondary {
      border: 1px solid var(--nord4);
      color: var(--nord6);
    }

    .btn-secondary:hover {
      background: var(--nord4);
      color: var(--nord0);
    }
  </style>
</head>

<body>
  <div class="error-card">
    <div class="error-code">404</div>
    <div class="error-title">Not Found</div>
    <p class="error-message">
        The server has not found anything matching the Request-URI   syntax
    </p>
  </div>
</body>
</html>
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:05:43 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:05:54 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga is known as the phosphate capital of Morocco.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga is known as the phosphate capital of Morocco.</p>
</body>
</html>
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:08:39 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:09:23 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga is known as the phosphate capital of Morocco.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga hosts an annual International Festival of Phosphate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga is known as the phosphate capital of Morocco.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The Hassan II Mosque in Casablanca has the world's tallest minaret.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Khouribga is known as the phosphate capital of Morocco.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>Morocco is home to the world's largest solar power plant, Noor Ouarzazate.</p>
</body>
</html>
HTTP/1.0 200 OK
Content-type: text/html

<html>
<head><title>Fun Fact About Morocco</title></head>
<body>
<h1>Did You Know?</h1>
<p>The traditional Moroccan dish, tagine, is both a meal and the name of the pot it's cooked in.</p>
</body>
</html>
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:36 GMT
Content-Type: text/html
Content-Length: 835

<html>
<head><title>Indexof /home/amabrouk/amabrouk/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/</h1><hr><pre><a href="../">../</a>
<a href=".git/">.git/</a>
<a href=".vscode/">.vscode/</a>
<a href="CGI/">CGI/</a>
<a href="Configuration/">Configuration/</a>
<a href="Request/">Request/</a>
<a href="Response/">Response/</a>
<a href="Server/">Server/</a>
<a href="tests/">tests/</a>
<a href="www/">www/</a>
<a href="Makefile">Makefile</a>
<a href="Test/">Test/</a>
<a href="errors/">errors/</a>
<a href="requirementsTest.txt">requirementsTest.txt</a>
<a href="sessions/">sessions/</a>
<a href="user_database">user_database</a>
<a href="Request.txt">Request.txt</a>
<a href="Response.txt">Response.txt</a>
<a href="main.cpp">main.cpp</a>
<a href="main.o">main.o</a>
<a href="webserv">webserv</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:39 GMT
Content-Type: text/html
Content-Length: 267

<html>
<head><title>Indexof /home/amabrouk/amabrouk/CGI/</title></head>
<body>
<h1>Index of /home/amabrouk/amabrouk/CGI/</h1><hr><pre><a href="../">../</a>
<a href="cgi.cpp">cgi.cpp</a>
<a href="cgi.hpp">cgi.hpp</a>
<a href="cgi.o">cgi.o</a>
</pre><hr></body>
</html>HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:40 GMT
Content-Type: text/plain
Content-Length: 1165
Last-Modified: Sat, 3 Jan 2026 16:52:59 GMT

#pragma once

#include "../Server/Client.hpp"

class CGI
{
	public:
		CGI();
		~CGI();
		enum CGIState { CGI_RUNNING, CGI_DONE };

		void	setScriptPath(const std::string &path);
		void	setMethod(const std::string &method);
		void	setQueryString(const std::string &query);
		void	setInputFile(const std::string &filePath);
		void	setHeader(const std::string &key, const std::string &value);
		void	setState(CGIState state) { _state = state; }

		pid_t	getPid() const;
		int		getOutFile() const;
		time_t	getStartTime() const;
		CGIState		getState() { return _state; }

		std::string	start();
		std::vector<CGIConfig>						cgi_c;

	private:
		std::string							_scriptPath;
		std::string							_method;
		std::string							_queryString;
		std::map<std::string, std::string>	_headers;
		pid_t								_pid;
		int									_outFile;
		time_t								_startTime;
		std::string							_inputFile;
		std::string							_outputFile;
		CGIState							_state;

	std::string	getCGIInterpreter(const std::string &path);
	std::map<std::string, std::string> setupEnvironment();
	char	**mapToEnvArray(const std::map<std::string, std::string>& env);
	void	freeEnvArray(char **envp);
};
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:41 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:42 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:42 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:42 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:43 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:43 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:43 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:43 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:43 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:44 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:44 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:44 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:44 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:44 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:44 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:45 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:45 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:45 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:45 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:45 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:45 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:46 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:46 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:46 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:46 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:46 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:46 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:47 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:47 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:47 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:47 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:48 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:48 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:48 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
HTTP/1.1 200 OK
Server: webserv
Date: Sat, 3 Jan 2026 17:21:48 GMT
Content-Type: text/plain
Content-Length: 5362
Last-Modified: Sat, 3 Jan 2026 16:52:38 GMT

#include "cgi.hpp"
#include <iostream>
#include <sstream>
#include <cstdlib>

CGI::CGI() 
	: _pid(-1), _outFile(-1), _startTime(0), _state(CGI_RUNNING)
{
}

CGI::~CGI()
{
	if (_outFile != -1)
	{
		close(_outFile);
		_outFile = -1;
	}
	if (!_inputFile.empty())
	{
		unlink(_inputFile.c_str());
		_inputFile.clear();
	}
	if (_pid > 0)
	{
		// kill(_pid, SIGKILL);
		waitpid(_pid, NULL, WNOHANG);
		_pid = -1;
	}
}

void CGI::setScriptPath(const std::string& path)
{
	_scriptPath = path;
}

void CGI::setMethod(const std::string& method)
{
	_method = method;
}

void CGI::setQueryString(const std::string& query)
{
	_queryString = query;
}

void CGI::setInputFile(const std::string& filePath)
{
	_inputFile = filePath;
}

void CGI::setHeader(const std::string& key, const std::string& value)
{
	_headers[key] = value;
}

pid_t CGI::getPid() const
{
	return _pid;
}

int CGI::getOutFile() const
{
	return _outFile;
}

time_t CGI::getStartTime() const
{
	return _startTime;
}

std::string CGI::getCGIInterpreter(const std::string& path)
{
	size_t	dotPos = path.rfind('.');
	if (dotPos == std::string::npos)
		return "";
	std::string ext = string(path.begin() + dotPos, path.end());
	for (std::vector<CGIConfig>::iterator it = cgi_c.begin();
		  it != cgi_c.end(); it++)
	{
		CGIConfig cgi_c_it = *it;
		if (cgi_c_it.extension == ext)
		{
			// std::cerr << cgi_c_it.path;
			return cgi_c_it.path;
		}
	}
	return "";
}

std::map<std::string, std::string> CGI::setupEnvironment()
{
    std::map<std::string, std::string> env;
    env["REQUEST_METHOD"] = _method;
    env["SCRIPT_FILENAME"] = _scriptPath;
    env["QUERY_STRING"] = _queryString;
    env["SERVER_PROTOCOL"] = "HTTP/1.0";
    env["GATEWAY_INTERFACE"] = "CGI/1.0";
    std::map<std::string, std::string>::iterator it = _headers.find("Content-Type");
    if (it != _headers.end())
        env["CONTENT_TYPE"] = it->second;
    // Convert HTTP headers to HTTP_* variables
    for (it = _headers.begin(); it != _headers.end(); ++it)
    {
        std::string key = "HTTP_" + it->first;
        for (size_t i = 0; i < key.length(); i++)
        {
            if (key[i] == '-')
                key[i] = '_';
            else if (key[i] >= 'a' && key[i] <= 'z')
                key[i] = key[i] - 32;
        }
        // std::cerr << it->first << ": " << it->second << "\n\n";
        env[key] = it->second;
    }
    return env;
}

char** CGI::mapToEnvArray(const std::map<std::string, std::string>& env)
{
	char** envp = new char*[env.size() + 1];
	size_t i = 0;
	for (std::map<std::string, std::string>::const_iterator it = env.begin();
		 it != env.end(); ++it)
	{
		std::string envVar = it->first + "=" + it->second;
		envp[i] = new char[envVar.length() + 1];
		std::strcpy(envp[i], envVar.c_str());
		i++;
	}
	envp[i] = NULL;
	return envp;
}

void CGI::freeEnvArray(char** envp)
{
	if (!envp)
		return;
	for (size_t i = 0; envp[i] != NULL; i++)
		delete[] envp[i];
	delete[] envp;
}


std::string CGI::start()
{
	std::ostringstream outputPath;
	outputPath << "/tmp/cgi_output_" << time(NULL);
	_outputFile = outputPath.str();

	int outputFd = open(_outputFile.c_str(), O_RDWR | O_CREAT | O_TRUNC, 0600);
	if (outputFd < 0)
	{
		std::cerr << "Failed to create output file: " << _outputFile << std::endl;
		throw 500;
    }
	close(outputFd);

	_startTime = time(NULL);

	_pid = fork();

	if (_pid < 0)
	{
		std::cerr << "Fork failed\n";
		unlink(_outputFile.c_str());
		throw 500;
	}
	if (_pid == 0)
	{
		if (!_inputFile.empty())
		{
			int inFd = open(_inputFile.c_str(), O_RDONLY | O_CLOEXEC);
			if (inFd < 0)
			{
				std::cerr << "Child: Failed to open input file: " << _inputFile << "\n";
				exit(10);
			}
			dup2(inFd, STDIN_FILENO);
			close(inFd);
		}
		else
		{
			int nullFd = open("/dev/null", O_RDONLY);
			dup2(nullFd, STDIN_FILENO);
			close(nullFd);
		}
		
		int outFd = open(_outputFile.c_str(), O_WRONLY | O_TRUNC | O_CLOEXEC);
		if (outFd < 0)
		{
			std::cerr << "Child: failed to open output file\n";
			exit(11);
		}
		
		dup2(outFd, STDOUT_FILENO);
		close(outFd);
		std::map<std::string, std::string> envMap = setupEnvironment();
		char **envp = mapToEnvArray(envMap);
		std::string interpreter = getCGIInterpreter(_scriptPath);
		std::cerr << "interpreter = " << interpreter << "\n";
		std::cerr << "script Path = " << _scriptPath << "\n";
		// std::cerr << "-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n";
		if (!interpreter.empty())
		{
			char *argv[3];
			argv[0] = const_cast<char*>(interpreter.c_str());
			argv[1] = const_cast<char*>(_scriptPath.c_str());
			argv[2] = NULL;
			execve(interpreter.c_str(), argv, envp);
			std::cerr << "execve failed: " << strerror(errno) << "\n";
		}
		else
		{
			char *argv[2];
			argv[0] = const_cast<char*>(_scriptPath.c_str());
			argv[1] = NULL;
			execve(_scriptPath.c_str(), argv, envp);
		}
		freeEnvArray(envp);
		std::cerr << "execve failed: " << strerror(errno) << "\n";
		exit(1);
	}
	else
		return _outputFile;
}
